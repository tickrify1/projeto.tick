// Serviço IA Adaptável - OpenAI e Gemini com Prompt Profissional
export interface AIAnalysisRequest {
  image: string; // base64
  symbol?: string;
  timeframe?: string;
  provider?: 'openai' | 'gemini';
}

export interface AIAnalysisResponse {
  analise_tecnica: string;
  decisao: string;
  justificativa_decisao: string;
  confianca_percentual: number;
  indicadores_utilizados: string[];
  simbolo_detectado?: string;
  preco_atual?: string;
  timeframe_detectado?: string;
  estrutura_mercado?: {
    tendencia_principal: string;
    sub_tendencias: string[];
    topos_fundos: string;
  };
  suportes_resistencias?: {
    suportes: number[];
    resistencias: number[];
    forca_niveis: string;
  };
  padroes_candlestick?: Array<{
    nome: string;
    tipo: string;
    confiabilidade: string;
    implicacao: string;
  }>;
  padroes_graficos?: Array<{
    nome: string;
    categoria: string;
    direcao_rompimento: string;
    alvo_projetado?: number;
  }>;
  gestao_risco?: {
    ponto_entrada: number;
    stop_loss: number;
    take_profit: number;
    relacao_risco_retorno: number;
  };
}

export interface FullAnalysisResponse extends AIAnalysisResponse {
  symbol: string;
  recommendation: 'BUY' | 'SELL' | 'HOLD';
  targetPrice: number;
  stopLoss: number;
  reasoning: string;
  technicalIndicators: Array<{
    name: string;
    value: number | string;
    signal: 'BULLISH' | 'BEARISH' | 'NEUTRAL';
    description: string;
  }>;
}

// Prompt Profissional para Análise Técnica
const PROFESSIONAL_TRADING_PROMPT = "PROMPT_MOVIDO_PARA_O_BACKEND";

// ==============================
// Fallback implementations used in frontend during local development
// These do NOT call external APIs and are safe without API keys
// ==============================

function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

function pick<T>(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)];
}

/**
 * Local fallback that simulates an AI chart analysis.
 * When the backend is unavailable, hooks call this function.
 */
export async function analyzeChartWithAI(req: AIAnalysisRequest): Promise<FullAnalysisResponse> {
  const symbol = req.symbol || 'CHART_ANALYSIS';
  const recommendation = pick(['BUY', 'SELL', 'HOLD'] as const);
  const confidenceBase = recommendation === 'HOLD' ? 65 : 75;
  const confidence = clamp(Math.round(confidenceBase + (Math.random() - 0.5) * 10), 55, 90);

  // Generate mock prices based on a base value
  const basePriceMap: Record<string, number> = {
    'BTCUSDT': 42000,
    'ETHUSDT': 2500,
    'AAPL': 180,
    'GOOGL': 140,
    'TSLA': 200
  };
  const base = basePriceMap[symbol] ?? 100;
  const priceVariation = base * ((Math.random() - 0.5) * 0.06);
  const current = base + priceVariation;

  const targetPrice = recommendation === 'BUY'
    ? current * 1.05
    : recommendation === 'SELL'
    ? current * 0.95
    : current;

  const stopLoss = recommendation === 'BUY'
    ? current * 0.98
    : recommendation === 'SELL'
    ? current * 1.02
    : current;

  const technicalIndicators = [
    {
      name: 'RSI',
      value: Math.round(30 + Math.random() * 40),
      signal: recommendation === 'BUY' ? 'BULLISH' : recommendation === 'SELL' ? 'BEARISH' : 'NEUTRAL' as const,
      description: 'Indicador de momentum baseado em força relativa'
    },
    {
      name: 'MACD',
      value: (Math.random() - 0.5).toFixed(2),
      signal: recommendation === 'BUY' ? 'BULLISH' : recommendation === 'SELL' ? 'BEARISH' : 'NEUTRAL' as const,
      description: 'Convergência/Divergência de Médias Móveis'
    }
  ];

  const reasoning = recommendation === 'BUY'
    ? 'Tendência de alta com confirmação por momentum e volume acima da média.'
    : recommendation === 'SELL'
    ? 'Pressão vendedora com perda de suporte e sinais de exaustão.'
    : 'Mercado em consolidação; aguardar rompimento com confirmação.';

  const response: FullAnalysisResponse = {
    symbol,
    recommendation,
    targetPrice: Math.round(targetPrice * 100) / 100,
    stopLoss: Math.round(stopLoss * 100) / 100,
    reasoning,
    technicalIndicators,
    analise_tecnica: reasoning,
    decisao: recommendation,
    justificativa_decisao: reasoning,
    confianca_percentual: confidence,
    indicadores_utilizados: technicalIndicators.map(i => i.name)
  };

  return new Promise(resolve => setTimeout(() => resolve(response), 300));
}

/**
 * Local fallback that simulates a trading signal generated by AI.
 */
export async function generateTradingSignal(symbol: string): Promise<{
  symbol: string;
  type: 'BUY' | 'SELL' | 'HOLD';
  confidence: number;
  price?: number;
  description: string;
}> {
  const type = pick(['BUY', 'SELL', 'HOLD'] as const);
  const confidence = clamp(Math.round(60 + Math.random() * 30), 55, 90);

  const description = type === 'BUY'
    ? 'Sinal de compra com confluência de indicadores técnicos (RSI, MACD, MAs).'
    : type === 'SELL'
    ? 'Sinal de venda com perda de suportes e fraqueza de momentum.'
    : 'Condições mistas; manutenção da posição recomendada.';

  return new Promise(resolve => setTimeout(() => resolve({
    symbol,
    type,
    confidence,
    description
  }), 200));
}
